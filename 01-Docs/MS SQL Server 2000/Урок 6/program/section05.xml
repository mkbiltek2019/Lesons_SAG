<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Представления."  предыдущий="section04.xml" следующий="HomeTask.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h2><font color="#800000">Представления.</font></h2>

<p>
Представления представляют из себя очень мощный механизм, позволяющий управлять введенными данными, а также позволяющий работать не со всей таблицей, а с ее частью, при этом требуемую часть можно указывать самостоятельно, плюс к этому существует возможность настраивать права доступа на какое то представление отдельно, тем самым упрощается система раздачи прав.
</p>

<p>
А теперь от разговоров к практике.
</p>

<p>
Представление представляет из себя часть таблицы, выбранную по определенному критерию. Критерий указывается в Where оператора Select. Общий синтаксис:
</p>

<pre style="border-color=#FF0000">

Create View Имя_представление AS

Select Имя_поля1, Имя_поля2, Имя_поляN

From Имя_таблицы

Where Условие

[With Check Option]

</pre>

<p>
Создается Представление, состоящее из значений, полученных из запроса Select. Имена полей представления будут совпадать с именами полей, указанными в запросе Select, но при желании их можно переименовать, указав псевдонимы для имен. Это удобно при создании представлений, использующем данные из нескольких таблиц.
</p>

<p>
При написании многотабличного запроса Select, вы обязаны указывать псевдонимы для полей с одинаковыми именами, т.к. в противном случае будет ошибка при создании представления!!!
</p>

<p>
Например. Возьмем базу данных Library и сделаем представление, хранящее в себе данные о имени, фамилии, дате выдачи и дате возврата книги.
</p>

<pre>

Create View MyView1 as

Select students.firstname, students.lastname,

s_cards.dateout,s_cards.datein

From students,s_cards

Where students.id=s_cards.id_student

</pre>

<p>
После этого запроса создастся представление MyView1. Увидеть его можно при помощи процедуры SP_HELP.
</p>

<p>
Положительная сторона работы с представлениями состоит в том, что по отношению к ним можно делать запросы на выборку, а также запросы на обновление информации, тем самым, изменяя структуру той таблицы, данные из которой находятся в представлении.
</p>

<p>
Например, чтобы просмотреть содержимое созданного представления достаточно сделать запрос типа:
</p>

<pre>

Select * 

From MyView1

</pre>

<p>
Результат:
</p>

<img src="img\pict5.jpg"></img>

<p>
Теперь на много облегчается процесс написания запросов. Пример2. Нужно показать студентов, которые вернули книги.
</p>

<pre>

Select * 

From MyView1

Where datein is not null

</pre>

<p>
Результат:
</p>

<img src="img\pict6.jpg"></img>

<p>
Есть еще окно колоссальное преимущество представлений. До сих пор, при помощи Group By можно было показывать список чего-либо. А что делать, если к этому списку необходимо вызвать какую-либо функцию агрегирования? Указать запрос, в качестве таблицы, из которой должна производиться вычитка, нельзя. Выход здесь единственный - на основе запроса с Group By создать представление, а уже по отношению к представлению делать запрос.
</p>

<p>
Задача - показать издательство, издавшее наибольшее кол-во страниц.
</p>

<pre style="color=#FF0000">
	ОШИБКА!!!

Select max(MySum1)

From (
	Select sum(books.pages) as MySum1, press.name

	from books,press

	where books.id_press=press.id

	group by press.name
          )

</pre>

<pre style="color=#FF0000">
	Правильно!!!
	<pre style="border-color=#00FF00">
	Create View MyView2 as 

	Select sum(books.pages) as MySum1, press.name

	from books,press

	where books.id_press=press.id

	group by press.name
	</pre>
Будет создано представление с полями MySum1 и name.

	<pre style="border-color=#00FF00">
	Select name, MySum1

	From MyView2

	Where MySum1=
		(

		Select max(MySum1) from MyView2

		)
	</pre>
</pre>

<p>
Результат:
</p>

<img src="img\pict7.jpg"></img>

<p>
Пример2 - Вычитать самую дешевую книгу из тематик Программирование, Базы данных клиент-сервер, Мультимедиа. База данных Books (многотабличная).
</p>

<pre style="border-color=#824000">
Вытягиваем книги требуемых издательств.
<pre>
	Create View MyView3 as

	select books.price,books.name as book,themes.name as theme

	From books,themes

	Where books.id_theme=themes.id and 

	themes.name in('Программирование', 'Базы данных клиент-сервер', 'Мультимедиа')
</pre>
Из них находим книгу, у которой цена минимальная.
<pre>
	Select book,theme

	From MyView3

	Where price=

		(

		Select min(price) from MyView3

		)

</pre>
</pre>

<p>
Результат:
</p>

<img src="img\pict8.jpg"></img>

<h3 align='center'><font color="#1925AB">Модификация Представлений.</font></h3>

<p>
Модификация представлений осуществляется при помощи все того же ключевого слова Alter. Общий синтаксис:
</p>

<pre>

Alter View Имя_представления As

Select Имя_поля1, Имя_поля2, Имя_поляN

From Имя_таблицы

Where Условие

</pre>

<p>
Если вы заметили, то вся разница лишь в том, что слово Create заменено на Alter. Но Alter View использовать лучше в том случае, если вы заботитесь о раздаче прав. Если удалить представление, то все права на него аннулируются и после повторного создания нужно будет настраивать их заново, а Alter View позволяет изменить представление, и оставить права на него не тронутыми.
</p>

<h3 align='center'><font color="#1925AB">Удаление Представлений.</font></h3>

<p>
Удаление представления производится при помощи ключевого слова Drop. Общий синтаксис:
</p>

<pre>

Drop View Имя_представления

</pre>

<h3 align='center'><font color="#1925AB">Изменение данных через Представления.</font></h3>

<p>
Существует возможность изменить данные, которые находятся в представлении, тем самым будет произведено изменение значений в исходной таблице. Имеется в виду, что при удалении либо изменении, либо добавлении информации в представление, она изначально изменяется либо добавляется в ту таблицу, значения из которой находятся в представлении.
</p>

<p>
Существует набор ограничений на изменение данных через представления.
</p>

<ol>
	<li>При добавлении значений в представление, поля основной таблицы, имеющие спецификатор Not NULL, обязаны иметь значение по умолчанию.</li>
	<li>Производить изменение данных в представлении, содержащем информацию из нескольких таблиц можно, только если изменения данных затрагивают только одну из них.</li>
	<li>Если в представлении есть поля, являющиеся результатом функции агрегирования, то значения этих полей менять нельзя.</li>
	<li>Если в представлении есть оператор UNION(он будет рассмотрен в следующих уроках), то к этому представлению можно делать только запросы на выборку.</li>
</ol>

<p>
Опция With Check Option позволяет указать, что ограничение, указанное в запросе Select обязано действовать при добавлении данных через представление.
</p>

<p>
Пример.
</p>

<pre>

Create View MyView4 as

Select firstname, lastname

From students

Where firstname like 'A%'

With Check Option

</pre>

<p>
Будет создано представление, в котором будет список студентов, имена у которых начинается с буквы А. Если после этого будет произведена попытка добавления данных, то, учитывая что указано With Check Option, добавлять можно будет только людей, у которых имя начинается с буквы А.
</p>

</Урок>