<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Понятие транзакции. Использование транзакций."  предыдущий="section04.xml" следующий="HomeTask.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">

<h2><font color="#800000">Понятие транзакции. Использование транзакций.</font></h2>

<p>
Транзакция - это механизм, позволяющий объединить набор операций в один логический блок, определяющий либо подтверждение полного выполнения каждой из операций, либо отмена всех из них.
</p>

<p>
Любая транзакция обладает четырьмя важными свойствами, определенными в английском языке, как свойства ACID (Atomicity, Consistency, Isolation, Durability). Обо всех по порядку.
</p>

<ol>
	<li>Atomicity - атомарность. Это свойство определяет неделимость транзакции, т.е. не может выполниться только какая либо ее часть, она выполняется либо полностью, либо не выполняется вообще.</li>
	<li>Consistency - связность. Определяет, что, как в случае успешного, так и аварийного завершения транзакции, это не может повлиять на целостность данных.</li>
	<li>Isolation - изолированность. Определяет, что одна транзакция не может взаимодействовать с другими транзакциями.</li>
	<li>Durability - надежность. Определяет, что выполнение транзакции не зависит от внешних факторов. Т.е. даже если вдруг выключили свет и сервер отключился в момент выполнения транзакции, то если она не закончила свое выполнение, после перезагрузки сервера, вся информация останется в первоначальном виде.</li>
</ol>

<p>
Транзакции подразделяются на 3 вида.
</p>

<ol>
	<li>Явные</li>
	<li>Неявные</li>
	<li>Автоматические</li>
</ol>

<h3 align='center'><font color="#1925AB">Явные транзакции.</font></h3>

<p>
Явные - это транзакции, заданные явно. Такие транзакции начинаются с ключевых слов </p>
<ul>
<li>Begin Tran, либо Begin Transaction</li>
<p>, а заканчиваться должны либо словами </p>
<li>Commit Tran, либо Commit Word</li>
<p>для успешного завершения работы транзакции, а </p>
<li>Rollback Tran, Rollback Transaction, либо Rollback Work</li> 
<p>для полного отката транзакции.</p>
</ul>

<p>
Например.
</p>

<pre>
Begin Transaction

Insert into books
values(771,8899,0,'Проверка работы транзакции',520,'Test',120,'20x20/15',
2004-05-03,1,'Использование транзакций','транзакции')

Select * from books
Where N=771

Commit Transaction
</pre>

<p>
Иногда требуется проверить, успешно ли завершился какой-либо запрос и относительно этого определить, начинать ли выполнение следующего запроса. Для отслеживания успешности операций служит специальная системная переменная @@ERROR. Если Запрос прошел успешно, то в эту переменную записывается ноль, если же произошла ошибка, то в нее записывается код ошибки. Это значение хранится в переменной до начала выполнения следующей транзакции.</p>

<pre>
Begin Transaction


Insert into books

values(771,8899,0,'Проверка работы транзакции',520,'Test',120,'20x20/15',

2004-05-03,1,'Использование транзакций','транзакции')

IF @@ERROR&lt;&gt;0

	BEGIN

		PRINT 'Error occured'

		rollback transaction

	END

ELSE


Commit Transaction
</pre>

<p>
Если вы поле N таблицы books сделаете первичным ключем (при помощи изменения настроек таблицы) и выполните указанную транзакцию, то на экране появится стандартное сообщение о том, что в поле, которое является первичным, нельзя записать два одинаковых значения, и, учитывая, что в переменной @@ERROR будет не ноль, то высветится еще настроенное нами сообщение Error occured и транзакция будет откатана.
</p>

<p>
Команда Rollback transaction откатывает всю выполняемую транзакцию. Но иногда требуется сохранить какую-либо уже успешно законченную операцию и ее не откатывать, даже если произошла ошибка в операции, указанной ниже. Для этого служит установка <b><i>точки сохранения</i></b>.
</p>

<p>
<b><i>Точка сохранения</i></b> - устанавливается при помощи команды 
</p>

<pre>Save Transaction имя_точки_сохранения</pre>

<p>
Тогда, для отката того, что находится после этой точки сохранения необходимо указывать команду: 
</p>

<pre>
Rollback transaction имя_точки_сохранения

commit transaction
</pre>

<p>
Если указать Rollback transaction, то будет произведен откат всей транзакции.
</p>

<p>
Если не указать commit transaction после Rollback transaction имя_точки_сохранения, то транзакция зависнет и доступа к базе данных, к которой производился запрос, не будет, вплоть до вызова этого же запроса с коммандой commit transaction.
</p>

<p>
Пример.
</p>

<pre>
Begin Transaction


insert into books (N,name,new,price) values (770,'Test1',1,12.53)


Save transaction savepoint1


insert into books (N,name,new,price) values (771,'Test1',1,12.53)


insert into books (N,name,new,price) values (770,'Test1',1,12.53)


if @@ERROR&lt;&gt;0

	begin

		print 'my error!!!'

		Rollback Transaction savepoint1

		Commit Transaction

	end

else

	Commit Transaction
</pre>

<p>
Давайте рассмотрим данный пример подробнее.
	<ul>
	<li>Определяем начало транзакции.</li>
	<li>Добавляем в таблицу books значения 770 - первичный ключ, Test1 - название книги, 1 - это книга новинка (это поле обязательное для заполнения), 12.53 - цена этой воображаемой книги.</li>
	<li>Устанавливаем точку сохранения.</li>
	<li>Добавляем в базу данных еще одну книгу, но номер ей указываем 771. Такого номера нет, потому этот запрос тоже выполнится.</li>
	<li><b><i>ВНИМАНИЕ</i></b> Добавляем в таблицу снова книгу с номером 770. Если N - первичный ключ, то происходит ошибка добавления записи, т.к. номера повторяются.</li>
	<li>Учитывая, что произошла ошибка, в переменной @@ERROR будет не ноль и команда PRINT 'строка' выведет на экран сообщение об ошибке.</li>
	<li>Производим откат всех операций, произведенных после точки сохранения. <b>Книга с номером 770 в базе должна остаться, а с номером 771, хотя запрос на добавление был выполнен успешно, сохранена не будет, за счет отката транзакции.</b></li>
	<li>Завершаем транзакцию.</li>
	</ul>
На этом примере очень четко можно рассмотреть работу транзакции. Мы определяем, что должен выполнится весь блок из трех запросов на добавление информации. Но мы также ограничиваем откат транзакции, используя точку сохранения. Т.е. если вызвать Rollback Transaction, то произойдет откат двух удачно выполненных запросов, но, учитывая точку сохранения, откатывается все, кроме тех операций, которые указаны до точки сохранения.
</p>

<h3 align='center'><font color="#1925AB">Неявные транзакции.</font></h3>

<p>
Работая с транзакциями, не всегда удобно для каждой из них указывать Begin Transaction. Если включить механизм неявных транзакций, то Begin Transaction дописывается автоматически. Но, учитывая, что транзакцию можно как закончить, так и отменить, ни Commit transaction, ни Rollback Transaction автоматически дописываться не будут. Их все равно необходимо в конце транзакции указывать явно.
</p>

<p>
Для включения механизма неявных транзакций необходимо указать:
</p>

<pre style="border:3px #FF0000 solid">
Set Implicit_transactions ON
</pre>

<p>
Чтобы выключить:
</p>

<pre style="border:3px #FF0000 solid">
Set Implicit_transactions OFF
</pre>

<h3 align='center'><font color="#1925AB">Автоматические транзакции.</font></h3>

<p>
Все дело в том, что даже если не указывать начало и конец транзакции, они все равно присутствуют. Например, запрос на вставку данных можно рассматривать как отдельную автоматическую транзакцию.
</p>

<p>
Пример.
</p>

<pre>
insert into books

values(772,8882,1,'Test2',125.23,'test_izd',550,'test_fromat',

2005-08-30,12501,'test_themes','test_category')
</pre>

<p>
В результате этой транзакции будет либо добавлена информация во все поля, либо не будет сохранена ни в одном из них. Так любой запрос сам по себе является транзакцией.
</p>


</Урок>