<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Подзапросы." 
предыдущий="section03.xml" следующий="section05.xml" copyright="© 2005 Вадим Волянский, Алексей Туманов.">
<h1 style="color:maroon">Подзапросы.</h1>

<p>
Очень часто всречается необходимость в запросе использовать результат какого-либо другого запроса. По сути это представляет из себя вложенность одного запроса в другой (В одном Select находится другой Select). Лучше всего необходимость этого рассмотреть на примере. </p>

<p>
Предположим, вам необходимо показать название книги, у которой максимальное кол-во страниц из всей базы данных books. Теоретически запрос должен выглядеть так:
</p>

<pre style="color=#FF0000">

ОШИБКА!!!

Select max(pages) as Max, name

From books

Group by name

</pre>

<p>
Но результатом будет совсем не то, что нужно.
</p>

<img src="img\pict15.jpg"></img>

<p>
На первый взгляд - это просто список всех книг. Это не совсем так. На самом деле названия книг выведены без повторений, и для каждой из групп указано максимальное кол-во страниц. Т.е. если есть 2 книги с одинаковым названием но с разним кол-вом страниц, то выведется одно название (учитывая, что группировка производится по названию) и максимальное кол-во страниц из этих двух книг. Если же название книги не повторяется, то она будет выведена на экран, как единственный представитель своей группы.
</p>

<p>
И тогда становится вопрос, а что же делать. И нам на помощь приходят Подзапросы. В любом запросе с начала выполняется вложенный запрос, а только после этого основной. Глубина вложенности ничем не ограничевается, поэтому лучше сказать, что с начала выполнится самый последний вложенный запрос, потом предпоследний и последним будет выполнен основной запрос. Любой вложенный запрос заключается в круглые скобки.
</p>

<p>
Теперь давайте посмотрим на проблему с максимумом с другой стороны. С начала нужно найти просто максимальное кол-во страниц. Это 1 запрос. После этого нужно найти название книги, у которой кол-во страниц равно максимальному.
</p>

<pre style="border-color=#FF0000">

select name,pages

from books

where pages=
	   (select max(pages)from books)

</pre>

<img src="img\pict16.jpg"></img>

<p>
С начала выполнится вложенный запрос (select max(pages)from books), который вернет, в результате, число 1296, определяющее максимальное кол-во страниц в таблице books. После этого внешний запрос находит название книги, у которой кол-во страниц равно 1296. Я думаю вы догадываетесь, что таких книг может быть несколько. Но важнее следить за тем, чтобы <b>вложенный запрос возвращал не более одной записи, при стандартном сравнении (&lt;, &gt;, &gt;=, &lt;=, = и т.д.)</b>. Но бывает обратная ситуация.
</p>

<p>
Пример2. Необходимо показать студентов, которые брали книгитематик 'Базы данных', либо 'Web-дазайн'.
</p>

<pre style="color=#FF0000">

ОШИБКА!!!

Select students.firstname

from students,s_cards

where s_cards.id_book =

		(

			select id from books where id_themes =

			(

				select id from themes where name in 

				('Базы данных','Web-дизайн')

			)

		)

and students.id=s_cards.id_student

</pre>

<p>
Дело все в том, что вложенный запрос, который вычитывает id тематик, возвращает более одной записи и поэтому проверять его рещультат на рывенство приводит к ошибке, как и запрос на уровень выше о id книг, этих тематик. Чтобы можно было сделать такой запрос необходимо знак " = " заменить на IN (проверка на членство в множестве).
</p>

<pre style="border-color=#FF0000">

Правильно!!!

Select students.firstname

from students,s_cards

where s_cards.id_book in

		(

			select id from books where id_themes in

			(

				select id from themes where name in 

				('Базы данных','Web-дизайн')

			)

		)

and students.id=s_cards.id_student

</pre>

<p>
В принципе, тот же самый результат можно было добиться, прописав связи между таблицами и указав дополнительное условие.
</p>

<p>
Существует ряд ограничений, которые накладываются на вложенные запросы:
	<ol>
		<li>Вложенный запрос необходимо всегда заключать в круглые скобки.</li>
		<li>Вложенный запрос не может содержать Select into, Order by.</li>
		<li>Вложенный запрос не может возвращать более одного столбца, если он включен в директиву In.</li>
		<li>Вложенный запрос не может указываться в Order by.</li>
	</ol>
</p>



</Урок>